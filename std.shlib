#!/bin/bash

std_shlib_version=1

#
# Global variables
#

export verbose=false
export debug=false
export dry_run=false
export help=false

#
# Activated by --verbose|-v. Relies on a "verbose" global variable
#
function debug
{
    ${verbose} && echo "$@" 1>&2;
    return 0
}

#
# Send error information at stderr and exit. The return code is 255.
#
function fail
{
    echo "[error]: $@" 1>&2 && exit 255
}

#
# Activated by --verbose|-v. Relies on a "verbose" global variable.
#
# Usage:
#
#        debug-arguments "$@"
#
# It is important to double-quote the argument, otherwise the empty arguments won't be displayed.
# TODO: Tested on Mac, must also test on Linux, cygwin
#
function debug-arguments
{
    local first=$1 # placeholder, to avoid IDE warnings
    local args
    if ${verbose}; then
        for arg do
            #
            # this is how we mask passwords
            #
            if [ "--aws-secret-key" = "${arg}" ]; then
                arg="--aws-secret-key ***"
            fi

            [ -z "${arg}" ] && arg="\"\""

            if [ -z "${args}" ]; then
                args="${arg}"
            else
                args="${args}, ${arg}"
            fi
        done
        echo "${FUNCNAME[1]}(${args})" 1>&2;
    fi
    return 0
}

#
# Send info at stderr (not to interfere with function returns)
#
function info
{
    echo "$@" 1>&2;
    return 0
}

#
# Send a warning at stderr (not to interfere with function returns)
#
function warn
{
    echo "[warning]: $@" 1>&2;
    return 0
}

#
# Send a TODO message at stderr (not to interfere with function returns)
#
function todo
{
    echo "[TODO]: $@" 1>&2;
    return 0
}

#
# Send error information at stderr (but not exit)
#
function error
{
    echo "[error]: $@" 1>&2;
    return 0
}

#
# Asks the question and it expects a y/n answer. If the answer starts with 'y', returns 0, otherwise it returns 1
#
function yes
{
    echo -n "$@ [y/n] " 1>&2;
    read line
    [ "${line:0:1}" = "y" ] && return 0 || return 1
}

#
# displays the arguments at stderr as [dry-run]. Does NOT exit.
#
function dry-run
{
    echo "[dry-run]: $@" 1>&2;
    return 0
}
#
# Process common options setting and exporting global variables (so these values are passed to sub-shells). There is no
# way (or I don't know of any way) to modify the caller's positional parameters as to remove the parameters processed
# by this function, but it sets an "args" global variable that contains the remaining parameters, so you can use that.
#
# Note that if you need to convert exported global variables back into common command line arguments (to pass them
# over ssh, for example), use 'serialize-common-arguments' function.
#
# The function will remove only the first occurence of --verbose, -v, --debug because lower layers may need the second
# occurence - as a command parameter of its own, for example
#
#
# Usage:
#           process-common-options $@
#
#           for i in ${args}; do
#               # process remaining parameters as ${i}
#           done
#
# Option Handled       Global Variable Set      Notes
#
# --verbose            export verbose=true
# -v                   export verbose=true
#
# --debug              export verbose=true      This should be used when we want to debug the process with a debugger
#                      export debug=true
#
# --dry-run            export dry_run=true
#
# --help               export help=true
# -h                   export help=true
#
function process-common-arguments
{
    debug-arguments $@
    args=""

    while [ $# -gt 0 ]; do
        if ! ${verbose} && [ "$1" = "--verbose" -o "$1" = "-v" ]; then
            export verbose=true
            # the second --verbose|-v will go into arguments
        elif ! ${verbose} && [ "$1" = "--debug" ]; then
            export verbose=true
            # we need to set this to pass it to sub-processes as argument
            export debug=true
            # the second --debug will go into arguments
        elif [ "$1" = "--dry-run" ]; then
            export dry_run=true
        elif [ "$1" = "-h" -o "$1" = "--help" ]; then
            export help=true
        else
            [ "${args}" = "" ] && args=$1 || args="${args} $1"
        fi
        shift
    done
}
